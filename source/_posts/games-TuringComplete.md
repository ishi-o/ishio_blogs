---
title: "Turing Complete: 图灵完备，一款数电小游戏"
date: 2024-05-03
categories: [Games]
tags: [Digital Circuit]
mathjax: true
---
<!-- placeholder -->
<!-- more -->
# `OVERTRUE`

`OVERTRUE`是最简单的图灵完备的处理器，即能够读取指令、分情况进行计算或跳转或转移数据，接下来从基础逻辑门开始搭建该架构

## 基础逻辑电路

### 基础逻辑门

**`NAND`与非门**是最为基础的逻辑门，根据德·摩根定理，能够用它和若干个**`NOT`非门**搭建其它三个基础门

- 它的真值表为$\begin{matrix}0&1&0&1\\0&0&1&1\\1&1&1&0\end{matrix}$，即**非$\begin{matrix}1\\1\end{matrix}$得$1$，否则得$0$**，画法为<img src="1.1.NAND.png" style="zoom: 15%;" />

- 通过它可以制造`NOT`，真值表为$\begin{matrix}0&1\\1&0\end{matrix}$，画法为<img src="1.2.NOT.png" style="zoom:15%;" />

- 对`NAND`门的**输出取反**，得到**`AND`与门**，逻辑为**$\begin{matrix}1\\1\end{matrix}$得$1$，否则得$0$**，真值表为`NAND`输出按位取反，画法为<img src="1.3.AND.png" style="zoom:15%;" />

- 对`NAND`门的**输入取反**，得到**`OR`或门**，逻辑为**非$\begin{matrix}0\\0\end{matrix}$得$1$，否则得$0$**，真值表为`NAND`输出左右颠倒，画法为<img src="1.4.OR.png" style="zoom:15%;" />

- 对`OR`门的输出取反(或对`AND`的输入取反)，得到**`NOR`或非门**，逻辑为**$\begin{matrix}0\\0\end{matrix}$得$1$，否则得$0$**，真值表为`OR`输出按位取反，画法为<img src="1.5.NOR.png" style="zoom:15%;" />

### 逻辑门扩展

各个基础逻辑门互相组合，能得到所有$2^4=16$种真值表，在这里扩展**`XOR`异或门**与**`XNOR`同或门**：

- 对`OR`门与`NAND`门的输出`AND`，得到`XOR`，逻辑为**输入不同得$1$，否则得$0$**，真值表为$\begin{matrix}0&1&0&1\\0&0&1&1\\0&1&1&0\end{matrix}$，画法为<img src="1.6.XOR.png" alt="1.6.XOR" style="zoom:15%;" />
- 对`XOR`门的输出取反(或对`NOR`门与`AND`门的输出`OR`)，得到`XNOR`，逻辑为**输入相同得$1$，否则得$0$**，真值表为`XOR`输出按位取反，画法为<img src="1.7.XNOR.png" style="zoom:15%;" />

### 其它

通过`OR`与`AND`，可实现始终输出高/低电平的电路**`ON`**与**`OFF`**

通过两个相同类型的基础逻辑门组合，可得到**三路输入**的对应逻辑门

通过三个`XOR`门组合，可实现在**四路输入奇数个信号时，输出$1$**

## 算术运算

### 二进制信号计数与二进制补码

- 通过三个`XOR`门组合，使得**当四路输入奇数个信号时，接入代表1的二进制输出上**
- 枚举四路输入，使得**当四路输入$2$或$3$个信号时，接入代表2的二进制输出上**
- 通过三个`AND`门组合，使得**当四路输入全为$1$时，接入代表$4$的二进制输出上**

总而言之，通过繁琐的排列组合，实现接受$255$路输入后，输出数值上最多表示$255$的单字节八位信号

为了方便，依然将这个信号用一点表示，使用**分线器**解散这个点，使用**集线器**构建这个点

二进制补码：将一个字节的最后一位视为$-128$后，即有**按位取反加$1$后变为其相反数**的特性

### 半加器与全加器与八位加法器

半加器指对**两路**$1$位输入求和，并用两路输出**本位和**与**进位**：

- 一个`XOR`门得到正确的本位和输出，即在$1+0=1$或$0+1=1$时输出$1$
- 一个`AND`门得到正确的进位输出，即在$1+1=10$时进位

全加器指对**三路**$1$位输入求和，并用两路输出**本位和**与**进位**：

- 通过两个`XOR`门，当输入信号为奇数个时在本位和处输出$1$
- 对两路输入通过半加器，当进位为$1$时，或本位和为$1$且第三路输入为$1$时，在全加器进位处输出$1$

八位加法器接受一个一位输入用于继承上一个八位加法器的进位；接受两个字节输入表示两个参数；输出一个一位信号表示三个数的进位；输出一个字节信号表示除进位外的和：

- 通过八个全加器与一个集线器即可得到八位加法器
- 附录中展现了高速八位加法器，能达到$61$逻辑门、$20$延迟

通过对第二个输入取相反数，实现减法

### 数据选择

根据一个$1$位信号输入来选择两路输入是很有价值的，所以需要**开关**：

- 当开关关闭时，既不输出高电平也不输出低电平，处于**高阻态**
- 两个开关即可实现数据选择，开关保证了在一路输出时不会受影响另一路影响
- 除了选择输入外，也可以用开关来选择输出端

## 数据存储

### 一位存储器

通过**延迟线**，能够将该刻的信号延迟到下一刻输出，实现存储器功能：

- 接受一个代表写入开关的输入和代表待写入数据的输入，且总是输出当前存储的数据
- 当表示是否写入的输入为$0$时，选择延迟线的输出，否则选择待写入数据
- 将这个信号传递给延迟线后进入下一刻，则存储器能通过读取输入判断是否要覆写数据，并在覆写前将旧数据输出

### 寄存器

通过八个$1$位存储器，实现**寄存器**，它额外接受一个代表读取的输入并拥有一个额外的输出端，只有当其为$1$时，将该刻数据输出到这个输出端上

### 计时器

想让一个处理器逐个读取指令，需要一个计时器：

- 本身处于计时模式，每过一刻钟自增固定数值；接受一个代表启动擦写的输入和一个代表待写入数值的输入；始终输出当前时刻的值
- 通过`ON`与数据选择器即可实现步进为$1$的计时器

### 解码器

所谓解码器，即将所有输入的所有组合输出，例如三位解码器有八位输出，这使得处理器能够处理不同的指令

通过解码器、开关与数据选择器，能够实现根据输入来选择不同运算或直接输出数据

## 总结

`OVERTRUE`架构将一条指令看作**复制、运算、条件判断、立即数**的任意一种，通过解码能够简单地实现读取地址、区分运算等功能，在本架构中通过两位信号四种可能来区分它们，接下来介绍如何实现该架构

在`OVERTRUE`架构中，能够操作的条件种类较少，主要是与$0$对比，或总是跳转，如果满足条件，将跳转到某一寄存器所指的地址

这个架构虽然具备自行处理指令的功能，但指令之间是隔离的，即运算功能使用固定的两个寄存器，跳转功能只判断一个固定的寄存器与一个固定的数值，立即数只能传入一个固定的寄存器，都需要通过复制来处理数据，对编写程序是极不友好的，而在之后的`LEG`框架能够有效提升性能

## 附录

### 基础逻辑门

`NOT`

<img src="1.8.NOTp.png" alt="1.8.NOTp" style="zoom:25%;" />

`NOR`

<img src="1.9.NORp.png" alt="1.9.NORp" style="zoom:25%;" />

`OR`

<img src="1.11.ORp.png" alt="1.11.ORp" style="zoom:25%;" />

`AND`

<img src="1.10.ANDp.png" alt="1.10.ANDp" style="zoom:25%;" />

`XOR`

<img src="1.12.XORp.png" alt="1.12.XORp" style="zoom:25%;" />

### 算数运算

一位半加器

<img src="1.14.半加器.png" alt="1.14.半加器" style="zoom: 33%;" />

一位全加器

<img src="1.15.全加器.png" alt="1.15.全加器" style="zoom: 33%;" />

高速八位加法器

![1.16.高速加法器](1.16.高速加法器.png)

### 时序逻辑电路基本元件

数据选择器

<img src="1.19.数据选择器.png" alt="1.19.数据选择器" style="zoom:50%;" />

计时器

<img src="1.17.计时器.png" alt="1.17.计时器" style="zoom:50%;" />

三位解码器

<img src="1.18.三位解码器.png" alt="1.18.三位解码器" style="zoom:50%;" />
